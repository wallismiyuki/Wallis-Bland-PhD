#######################################################
# Reorder a castor simulation from e.g. simulate_tdsse2()
# to the default APE node order
#
# Procedure: 
# 1. prints simulation$tree to a newick file,
#    then reads it back in
#
# 2. Reorders the simulation$tip_states and simulation$node_states to match 
#
# 3. Adds simulation$states, to put all the states in one place
#######################################################
reorder_castor_sim_to_default_ape_node_order <- function(simulation)
	{
	# Make tree table from simulation tree
	simtree = simulation$tree
	simtable = prt(simtree, printflag=FALSE, get_tipnames=TRUE)
	
	# Simtree nodes are in date order from the root
	internal_nodes = (length(simtree$tip.label)+1):(length(simtree$tip.label)+simtree$Nnode)
	simulation_nodestate_order_in_prt = order(simtable$node_ht[internal_nodes])
	simulation_nodestate_order_in_prt
	
	# translation table
	simstate_translation_table = cbind(1:simtree$Nnode, simulation_nodestate_order_in_prt)
	tmp = simstate_translation_table[order(simstate_translation_table[,2]),]
	simstates_to_prt_order = tmp[,1]
	
	# simtree_nodenums to APE order
	#match(x=1:simtree$Nnode, table=simtree_nodenums)

	# Write simtree to Newick; read back in to get standard APE newick format
	newtree = read.tree(file="", text=write.tree(simulation$tree, file=""))
	# Write tree table for new tree
	newtable = prt(newtree, printflag=FALSE, get_tipnames=TRUE)

	match_simtree_in_new2 = match(x=newtable$tipnames, table=simtable$tipnames)
	match_simtree_in_new2

	match_simtree_in_new2sub_tips = match_simtree_in_new2[match_simtree_in_new2 <= length(simtree$tip.label)]
	match_simtree_in_new2sub_nodes = match_simtree_in_new2[match_simtree_in_new2 > length(simtree$tip.label)]-length(simtree$tip.label)
	
	simstates_OLD = c(as.numeric(simulation$tip_states), as.numeric(simulation$node_states))
	simstates = c(as.numeric(simulation$tip_states), as.numeric(simulation$node_states[simstates_to_prt_order]))

	simstates
	simstates[match_simtree_in_new2]

	simulation$node_states
	simulation$node_states[match_simtree_in_new2sub_nodes]
	
	simulation$tip_states
	simulation$tip_states[match_simtree_in_new2sub_tips]
	
	# Re-save the re-ordered simulation
	simulation2 = simulation
	simulation2$tree = newtree
	simulation2$node_states = simulation$node_states[match_simtree_in_new2sub_nodes]
	simulation2$tip_states = simulation$tip_states[match_simtree_in_new2sub_tips]
	
	# BAD: RE-LABELS TIPS
	#names(simulation2$tip_states) = 1:length(simulation2$tip_states)
	names(simulation2$tip_states)
	
	# Same thing twice
	simulation2$states = simstates[match_simtree_in_new2]
	simulation2$simstates = c(unname(simulation2$tip_states), simulation2$node_states)
	return(simulation2)
	} # END reorder_castor_sim_to_default_ape_node_order




# This assumes the list of states can be generated by
# rcpp_areas_list_to_states_list(); a manual states list 
# would need another function
#
# THIS ASSUMES simulation2 = reorder_castor_sim_to_default_ape_node_order(simulation)
# ...HAS BEEN RUN...
plot_castor_simulation <- function(simulation, areas=c("A","B"), max_range_size=2, include_null_range=TRUE)
	{
	defaults='
	areas = c("A", "B")
	max_range_size = 2
	include_null_range = TRUE
	'
	simtree = simulation$tree
	simstates = c(unname(simulation$tip_states), simulation$node_states)
	
	states_list_0based = rcpp_areas_list_to_states_list(areas=areas, maxareas=max_range_size, include_null_range=include_null_range)
	states_list_0based

	possible_ranges_list_txt = areas_list_to_states_list_new(areas=areas,  maxareas=max_range_size, split_ABC=FALSE, include_null_range=include_null_range)
	possible_ranges_list_txt

	# Make the list of ranges by node
	ranges_list = NULL

	for (i in 1:length(states_list_0based))
			{    
			if ( (length(states_list_0based[[i]]) == 1) && (is.na(states_list_0based[[i]])) )
					{
					tmprange = "_"
					} else {
					tmprange = paste(areas[states_list_0based[[i]]+1], collapse="")
					}
			ranges_list = c(ranges_list, tmprange)
			}

	# Look at the ranges list
	ranges_list

	colors_matrix = get_colors_for_numareas(length(areas))
	colors_list_for_states = mix_colors_for_states(colors_matrix, states_list_0based_index=states_list_0based, plot_null_range=include_null_range)
	colors_list_for_states[length(colors_list_for_states)] = "cyan"   # usually "all areas" is white, 
																																			# but with just AB, I like orange

	# Get the colors by node
	statetxt_by_node = rep("_", times=length(simstates))
	for (i in 1:length(statetxt_by_node))
		{
		statetxt_by_node[i] = ranges_list[simstates[i]]
		}
	statetxt_by_node
	
	cols_byNode = rangestxt_to_colors(possible_ranges_list_txt, colors_list_for_states, MLstates=statetxt_by_node)
	cols_byNode

	# Plot the original simtree
	tipnums = 1:length(simtree$tip.label)
	nodenums = (length(simtree$tip.label)+1):(length(simtree$tip.label)+simtree$Nnode)
	plot(simtree, show.tip.label=FALSE)
	axisPhylo()
	mtext(text="Millions of years ago (Mega-annum, Ma)", side=1, line=2.5)
	title("Plotting simtree & states from simulate_tdsse2()")
	tiplabels(text=statetxt_by_node[tipnums], tip=tipnums, bg=cols_byNode[tipnums])
	nodelabels(text=statetxt_by_node[nodenums], node=nodenums, bg=cols_byNode[nodenums])

	return(cols_byNode)
	} # END plot_castor_simulation





# plot_castor simulation, for only living tips
# 
# This assumes the list of states can be generated by
# rcpp_areas_list_to_states_list(); a manual states list 
# would need another function
#
# THIS ASSUMES simulation2 = reorder_castor_sim_to_default_ape_node_order(simulation)
# ...HAS BEEN RUN...
plot_castor_simulation_LIVING <- function(simulation, areas=c("A","B"), max_range_size=2, include_null_range=TRUE, tip_age_tolerance=1e-6)
	{
	defaults='
	areas = c("A", "B")
	max_range_size = 2
	include_null_range = TRUE
	'
	simtree = simulation$tree
	simstates = c(unname(simulation$tip_states), simulation$node_states)
	
	states_list_0based = rcpp_areas_list_to_states_list(areas=areas, maxareas=max_range_size, include_null_range=include_null_range)
	states_list_0based

	possible_ranges_list_txt = areas_list_to_states_list_new(areas=areas,  maxareas=max_range_size, split_ABC=FALSE, include_null_range=include_null_range)
	possible_ranges_list_txt

	# Make the list of ranges by node
	ranges_list = NULL

	for (i in 1:length(states_list_0based))
			{    
			if ( (length(states_list_0based[[i]]) == 1) && (is.na(states_list_0based[[i]])) )
					{
					tmprange = "_"
					} else {
					tmprange = paste(areas[states_list_0based[[i]]+1], collapse="")
					}
			ranges_list = c(ranges_list, tmprange)
			}

	# Look at the ranges list
	ranges_list

	colors_matrix = get_colors_for_numareas(length(areas))
	colors_list_for_states = mix_colors_for_states(colors_matrix, states_list_0based_index=states_list_0based, plot_null_range=include_null_range)
	colors_list_for_states[length(colors_list_for_states)] = "cyan"   # usually "all areas" is white, 

	# SUBSET TO LIVING
	tip_ages_above_root = get_node_ages_of_tips(simulation$tree)
	root_age = max(tip_ages_above_root)

	#tip_age_tolerance = 1e-6
	fossils_TF = (root_age - tip_ages_above_root) > tip_age_tolerance

	# 1. output a successful simulation
	# 2. save to a living tree and complete tree
	tr = simulation$tree
	tr$node.label = paste0("in", ((length(tr$tip.label)+1):(length(tr$tip.label)+tr$Nnode)))
	tr$tip.label = paste0("sp", tr$tip.label)
	tips_to_drop = tr$tip.label[fossils_TF]
	living_tree = drop.tip(phy=tr, tip=tips_to_drop)
	
	full_tree_tipnode_labels = c(tr$node.label, tr$tip.label)
	living_tree_tipnode_labels = c(living_tree$node.label, living_tree$tip.label)
	
	index_in_fulltree_matching_living_tree_node = match(living_tree$node.label, table=tr$node.label)
	index_in_fulltree_matching_living_tree_tipnode = match(living_tree$tip.label, table=tr$tip.label)

	living_tip_states = simulation$tip_states[index_in_fulltree_matching_living_tree_tipnode]
	living_node_states = simulation$node_states[index_in_fulltree_matching_living_tree_node]
	simstates = c(living_tip_states, living_node_states)
	# ######################
	# done subsetting to living

	# Get the colors by node
	statetxt_by_node = rep("_", times=length(simstates))
	for (i in 1:length(statetxt_by_node))
		{
		statetxt_by_node[i] = ranges_list[simstates[i]]
		}
	statetxt_by_node
	
	cols_byNode = rangestxt_to_colors(possible_ranges_list_txt, colors_list_for_states, MLstates=statetxt_by_node)
	cols_byNode

	# Plot the original simtree
	tipnums = 1:length(living_tree$tip.label)
	nodenums = (length(living_tree$tip.label)+1):(length(living_tree$tip.label)+living_tree$Nnode)
	plot(living_tree, show.tip.label=FALSE)
	axisPhylo()
	mtext(text="Millions of years ago (Mega-annum, Ma)", side=1, line=2.5)
	title("Plotting LIVING simtree & states from simulate_tdsse2()")
	tiplabels(text=statetxt_by_node[tipnums], tip=tipnums, bg=cols_byNode[tipnums])
	nodelabels(text=statetxt_by_node[nodenums], node=nodenums, bg=cols_byNode[nodenums])

	return(cols_byNode)
	} # END plot_castor_simulation_LIVING














default_simfns <- function()
	{
	simfns = c("setup_df.txt",
	"timepoints.txt", 
	"mu_vals_by_t.txt",
	"Qvals_by_t.txt",
	"Crates_by_t.txt",
	"Qarray.txt",
	"Carray.txt",
	"area_names.txt",
	"states_list.R")
	return(simfns)
	}


# Simulate for a certain period of time, until minimum number of living taxa produced
starter="
library(BioGeoBEARS)
source('/GitHub/PhyBEARS.jl/Rsrc/castor_helpers.R')

wd = '/GitHub/PhyBEARS.jl/ex/siminf_v12a/'
start_state = 2 # number of the starting state
max_simulation_time = 15.0 # Set to 0 if the user doesn't want to set a max simulation time
min_tips = 50
max_tips=100
simfns=default_simfns()
seedval = 54321
max_rate=10.0
numtries = 1000

start_state=2; max_simulation_time=15; min_tips=50; max_tips=100; simfns=default_simfns(); seedval=54321; max_rate=10.0; numtries=1000

simulate_tdsse2_for_timeperiod(wd, start_state, max_simulation_time, min_tips, max_tips, simfns, seedval, max_rate, numtries)
"
simulate_tdsse2_for_timeperiod <- function(wd, start_state=2, max_simulation_time=10, min_tips=2, max_tips=NULL, simfns=default_simfns(), seedval=54321, max_rate=10.0, numtries=1000)
	{
	# Error check
	if (max_tips < min_tips)
		{
		txt = paste0("STOP ERROR in simulate_tdsse2_for_timeperiod(): max_tips=", max_tips, " < min_tips=", min_tips, ". This is an impossible simulation condition. Change inputs and re-run.") 
		stop(txt)
		}

	if (abs(max_tips - min_tips) < 6)
		{
		txt = paste0("WARNING in simulate_tdsse2_for_timeperiod(): max_tips=", max_tips, " < min_tips=", min_tips, ". This is a range of less than 5 tips/species. It may be difficult for the simulator to provide trees of a size this precise.")
		cat("\n")
		cat(txt)
		cat("\n")
		warning(txt) 
		}

	
	
	# Add wd to the filename (stripping any prior paths from simfns)
	for (i in 1:length(simfns))
		{
		simfns[i] = get_path_last(simfns[i])
		simfns[i] = slashslash(paste0(wd, "/", simfns[i]))
		}

	# Get the area_names and states_list
	area_names = c(read.table(simfns[8]))[[1]]
	# states_list = 
	source(simfns[9]) # Creates a states_list
	
	# Read in the setup
	setup_df = read.table(simfns[1], header=TRUE)
	numareas = setup_df$numareas
	numstates = setup_df$numstates
	max_range_size = setup_df$max_range_size
	if (tolower(setup_df$include_null_range) == "true")
		{
		include_null_range = TRUE
		} else {
		include_null_range = FALSE
		}

	# User sets these here!
	# Set the random number seed, to make it repeatable
	set.seed(seedval)
	# Set the max_simulation time -- whatever changing distances you have will be
	# extended with this timepoint, i.e. the final geography/rates will continue
	# to this timepoint
	#start_state = 8 # number of the starting state
	#max_simulation_time = 15.0 # Set to 0 if the user doesn't want to set a max simulation time
	#max_tips = NULL

	# Set a maximum rate for extreme cases
	#max_rate = 10.0


	# Read timepoints
	# Read in Q/A matrix, populate one and array
	# Read in C matrix, populate one and array

	# Load the files
	#time_grid = seq(0,10,0.1) # About halfway through
	time_grid = c(read.table(simfns[2], header=FALSE))[[1]]

	# Change from time reading backwards to time reading forwards
	colnums = rev(1:length(time_grid))
	time_grid = -1*(max(time_grid) - time_grid) - min(-1*(max(time_grid) - time_grid))
	time_grid
	mu_vals_by_t = as.matrix(read.table(simfns[3], header=FALSE))[,colnums]
	Qvals_by_t = as.matrix(read.table(simfns[4], header=FALSE))[,colnums]
	Crates_by_t = as.matrix(read.table(simfns[5], header=FALSE))[,colnums]
	Qarray = read.table(simfns[6], header=TRUE)
	Carray = read.table(simfns[7], header=TRUE)

	# Add the final time at end of forward simulation, if needed
	if (max(time_grid) < max_simulation_time)
		{
		time_grid = c(time_grid, max_simulation_time)
		mu_vals_by_t = cbind(mu_vals_by_t, mu_vals_by_t[,ncol(mu_vals_by_t)])
		Qvals_by_t = cbind(Qvals_by_t, Qvals_by_t[,ncol(Qvals_by_t)])
		Crates_by_t = cbind(Crates_by_t, Crates_by_t[,ncol(Crates_by_t)])
		}


	# Enforce maximum rate on Crates_by_t
	Crates_by_t[Crates_by_t > max_rate] = max_rate
	mu_vals_by_t[mu_vals_by_t > max_rate] = max_rate

	# Produce the A transition matrix / array
	A = array(data=0.0, dim=c(numstates,numstates,length(time_grid)))
	for (i in 1:length(time_grid))
		{
		for (j in 1:nrow(Qarray))
			{
			A[Qarray$i[j],Qarray$j[j],i] = Qvals_by_t[j,i]
			}
	
		# Enforce maximum rate
		A[A > max_rate] = max_rate
	
		# Set the diagonal
		diag(A[,,i]) = 0.0
		diag(A[,,i]) = -rowSums(A[,,i])
		}

	# Cladogenetic part of the DEC model
	# At speciation, we have:
	# Specify probabilities of different events, given that speciation has occurred
	# (ADD THESE UP to provide the speciation rates / lambdas)

	# transition_table_C: columns are i, j, k, prob
	# transition_table_rates_C_matrix: columns are i, j, k, rate 
	# (later, we will add up these rates to get the total lambda by state)
	transition_table_C = NULL
	transition_table_probs_C_matrix = array(data=0.0, dim=c(nrow(Crates_by_t), 4, length(time_grid)))
	transition_table_rates_C_matrix = array(data=0.0, dim=c(nrow(Crates_by_t), 4, length(time_grid)))
	dim(transition_table_probs_C_matrix)
	dim(transition_table_rates_C_matrix)

	rates_sums_by_t = NULL
	for (i in 1:length(time_grid))
		{
		tmprates = as.data.frame(cbind(Carray$i, Carray$j, Carray$k, Crates_by_t[,i]), stringsAsFactors=FALSE)
		names(tmprates) = c("i", "j", "k", "rates_t")
		# Convert rates to probabilities
		rates_sums = aggregate(tmprates$rates_t, by=list(tmprates$i), FUN=sum)
		# Column names
		names(rates_sums) = c("i", "rates_sum")
	
	
		# Make sure rates_sums are ordered by 'i' (ancestral state index)
		tmporder = order(rates_sums$i)
		rates_sums = rates_sums[tmporder,]
	
		# Check for null range; add row for "i" if needed
		if (rates_sums$i[1] == 2)
			{
			tmprow = as.data.frame(matrix(data=c(1,0.0), nrow=1), stringsAsFactors=FALSE)
			names(tmprow) = c("i", "rates_sum")
			rates_sums = rbind(tmprow, rates_sums)
			}
	
		rates_sums_by_t	= cbind(rates_sums_by_t, rates_sums$rates_sum)

		# Convert rates to probabilities
		tmpprobs = tmprates
		names(tmpprobs) = c("i", "j", "k", "probs_t")
		for (q in 1:nrow(rates_sums))
			{
			tmpi = rates_sums$i[q]
			TF = tmprates$i == tmpi

			tmpprobs$probs_t[TF] = tmprates$rates_t[TF] / rates_sums$rates_sum[q]
			}
	
		transition_table_rates_C_matrix[,,i] = as.matrix(tmprates)
		transition_table_probs_C_matrix[,,i] = as.matrix(tmpprobs)
		}


	# Square transition matrix (not used, but sanity check)
	transition_matrix_C = array(data=0.0, dim=c(numstates,numstates,1))
	transition_matrix_C_array = array(data=0.0, dim=c(numstates,numstates,length(time_grid)))
	for (i in 1:length(time_grid))
		{
		for (j in 1:nrow(Carray))
			{
			if ((Carray$i[j] == Carray$j[j]) && (Carray$i[j] == Carray$k[j]))
				{
				# state i = state j = state k
				transition_matrix_C_array[Carray$i[j],Carray$j[j],i] = transition_matrix_C_array[Carray$i[j],Carray$j[j],i] + Crates_by_t[j,i] / rates_sums_by_t[Carray$i[j],i]
				} else {
				# Otherwise, you have two different "anagenetic" events, with the probability split between them
				transition_matrix_C_array[Carray$i[j],Carray$j[j],i] = transition_matrix_C_array[Carray$i[j],Carray$j[j],i] + Crates_by_t[j,i] / rates_sums_by_t[Carray$i[j],i] / 2
				transition_matrix_C_array[Carray$i[j],Carray$k[j],i] = transition_matrix_C_array[Carray$i[j],Carray$k[j],i] + Crates_by_t[j,i] / rates_sums_by_t[Carray$i[j],i] / 2
				}
			# Ignore, rates are already doubled if needed
			# if (Carray$i[j] != Carray$j[j])
			}
		# DO NOT set the diagonal on the cladogenetic transition rates
		#diag(transition_matrix_C_array[,,i]) = 0.0
		#diag(transition_matrix_C_array[,,i]) = -rowSums(transition_matrix_C_array[,,i])

		# Null range correction
		if (rowSums(transition_matrix_C_array[,,i])[1] == 0.0)
			{
			transition_matrix_C_array[1,1,i] = 1.0
			}
		}
	transition_matrix_C = transition_matrix_C_array[,,dim(transition_matrix_C_array)[3]]
	transition_matrix_C
	rowSums(transition_matrix_C)


	# Check probs
	for (i in 1:length(time_grid))
		{
		tmpprobs = transition_table_probs_C_matrix[,,i]
		probs_sum = aggregate(tmpprobs[,4], by=list(tmpprobs[,1]), FUN=sum)
		tmprates = transition_table_rates_C_matrix[,,i]
		rates_sum = aggregate(tmprates[,4], by=list(tmprates[,1]), FUN=sum)
		sums_by_i = cbind(rates_sum, probs_sum[,2])
		names(sums_by_i) = c("i", "rates_sum", "probs_sum")
		#print(sums_by_i)
		}


	# convert from 1-based to 0-based indices (turns out this is NOT needed for the C++ code)
	# transition_table_indices_C = transition_table_C[,1:3] - 1
	transition_table_indices_C = transition_table_rates_C_matrix[,1:3,1] - 1
	transition_table_indices_C_matrix = array(data=transition_table_indices_C, dim=c(dim(transition_table_indices_C),length(time_grid)))
	# transition_table_probs_C1 = transition_table_C[,4]
	transition_table_probs_C1 = transition_table_probs_C_matrix[,4,1]






	# Make the arrays for the parameters

	# Probs encoded in a num_clado_events * 2 * num_times array
	# the "2" just duplicates, ensures we have a 3D array
	transition_table_probs_C = array(data=0.0, dim=c(nrow(transition_table_indices_C), 2, length(time_grid)))

	# Fill in the transition_matrix_C and transition_table_probs
	for (i in 1:length(time_grid))
		{
		transition_table_probs_C[,1,i] = transition_table_probs_C_matrix[,4,i]
		transition_table_probs_C[,2,i] = transition_table_probs_C_matrix[,4,i]
		}


	parameters = list(birth_rates         = rates_sums_by_t,
										death_rates         = mu_vals_by_t,
										transition_matrix_A = A,
										transition_matrix_C = transition_matrix_C_array,
										transition_table_indices_C = transition_table_indices_C,
										transition_table_probs_C = transition_table_probs_C )
 

	# simulation
	
	sim_done = FALSE
	trynum = 1
	num_living_tips = NULL
	while(sim_done == FALSE)
		{
		if (trynum > numtries)
			{
			meanval = round(mean(num_living_tips), digits=2)
			lower95 = round(quantile(num_living_tips, prob=0.025), digits=2)
			upper95 = round(quantile(num_living_tips, prob=0.975), digits=2)
			minval = min(num_living_tips)
			maxval = max(num_living_tips)
			
			txt2 = paste0("Simulation averages: ", meanval, " living tips (95% quantile: ", lower95, ", ", upper95, "), range: (", minval, ", ", maxval, ").")
			
			txt = paste0("simulate_tdsse2() obtained no qualifying simulations after ", numtries, " tries. Increase numtries, increase max_simulation_time, or reduce max_tips.\n", txt2)
			cat("\n")
			cat(txt)
			cat("\n")
			sim_done = TRUE
			return(warning(txt))
			break()
			}

		simulation = simulate_tdsse2( Nstates = numstates, 
																parameters = parameters, 
																splines_degree      = 1,
																start_state = start_state,
																max_tips = max_tips,
																max_time = max_simulation_time,
																time_grid = time_grid,
																include_birth_times=TRUE,
																include_death_times=TRUE,
																coalescent=FALSE)

		if (simulation$success == FALSE)
			{ trynum=trynum+1; next() }

		if (length(simulation$tree$tip.label) < 3)
			{ trynum=trynum+1; next() }
		
		
		
		# Otherwise, proceed
		simulation2 = reorder_castor_sim_to_default_ape_node_order(simulation)
		tip_ages_above_root = get_node_ages_of_tips(simulation2$tree)
		root_age = max(tip_ages_above_root)
		
		tip_age_tolerance = 1e-6
		fossils_TF = (root_age - tip_ages_above_root) > tip_age_tolerance
		
		num_tips_in_present = sum(fossils_TF == FALSE)
		num_living_tips = c(num_living_tips, num_tips_in_present)
		
		# Check for successful simulation
		if (num_tips_in_present < min_tips)
			{ trynum=trynum+1; next() }
		
		# All checks passed; so keep the tree
		sim_done = TRUE
		
		} # END while(sim_done == FALSE)
		
	# Otherwise, proceed
	# 1. output a successful simulation
	# 2. save to a living tree and complete tree
	tr = simulation2$tree
	tr$node.label = paste0("in", ((length(tr$tip.label)+1):(length(tr$tip.label)+tr$Nnode)))
	tr$tip.label = paste0("sp", tr$tip.label)
	tips_to_drop = tr$tip.label[fossils_TF]
	living_tree = drop.tip(phy=tr, tip=tips_to_drop)
	
	full_tree_tipnode_labels = c(tr$node.label, tr$tip.label)
	living_tree_tipnode_labels = c(living_tree$node.label, living_tree$tip.label)
	
	index_in_fulltree_matching_living_tree_node = match(living_tree$node.label, table=tr$node.label)
	length(index_in_fulltree_matching_living_tree_node)
	length(living_tree$node.label)
	length(tr$node.label)

	index_in_fulltree_matching_living_tree_tipnode = match(living_tree_tipnode_labels, table=full_tree_tipnode_labels)
	length(index_in_fulltree_matching_living_tree_tipnode)
	length(living_tree_tipnode_labels)
	length(full_tree_tipnode_labels)


	#trtable_all = prt(t=tr, printflag=FALSE, get_tipnames=TRUE)
	#trtable_living = prt(t=living_tree, printflag=FALSE, get_tipnames=TRUE)
	
	
	outfn = slashslash(paste0(wd, "/", "living_tree.newick"))
	write.tree(living_tree, file=outfn)
	living_tree_noNodeLabels = living_tree
	living_tree_noNodeLabels$node.label = NULL
	outfn = slashslash(paste0(wd, "/", "living_tree_noNodeLabels.newick"))
	write.tree(living_tree_noNodeLabels, file=outfn)
	
	outfn = slashslash(paste0(wd, "/", "full_tree.newick"))
	write.tree(tr, file=outfn)
	outfn = slashslash(paste0(wd, "/", "tree_wFossils.newick"))
	write.tree(tr, file=outfn)
	tree_wFossils_noNodeLabels = tr
	tree_wFossils_noNodeLabels$node.label = NULL
	outfn = slashslash(paste0(wd, "/", "tree_wFossils_noNodeLabels.newick"))
	write.tree(tree_wFossils_noNodeLabels, file=outfn)
	
	
	#	3. geog files for both
	
	# Write out the geography files
	all_tip_states = simulation2$tip_states
	
	tipnames = tr$tip.label
	tmpdf = NULL
	for (i in 1:length(all_tip_states))
		{
		tmprow = rep(0, times=length(area_names))
		tmpstate = states_list[all_tip_states[i]][[1]]
		tmprow[tmpstate] = 1
		tmpdf = rbind(tmpdf, tmprow)
		}
	
	tmpdf = as.data.frame(tmpdf)
	names(tmpdf) = area_names
	row.names(tmpdf) = paste0("sp", names(all_tip_states))
	tipranges = define_tipranges_object(tmpdf=tmpdf)
	
	lgdata_fn = slashslash(paste0(wd, "/", "geog_wFossils.data"))
	save_tipranges_to_LagrangePHYLIP(tipranges, lgdata_fn=lgdata_fn, areanames=area_names)
	
	# Subset to living-only
	rows_to_drop_TF = row.names(tmpdf) %in% tips_to_drop
	rows_to_keep_TF = rows_to_drop_TF == FALSE
	tmpdf2 = tmpdf[rows_to_keep_TF,]
	tipranges2 = define_tipranges_object(tmpdf=tmpdf2)
	lgdata_fn = slashslash(paste0(wd, "/", "geog_living.data"))
	save_tipranges_to_LagrangePHYLIP(tipranges2, lgdata_fn=lgdata_fn, areanames=area_names)
	
	#	4. save the Rdata file
	outfn = slashslash(paste0(wd, "/", "simulation2.Rdata"))
	save(simulation2, file=outfn)
	
	#	5. save the states at tips & nodes
	outfn = slashslash(paste0(wd, "/", "simstates_all.txt"))
	write.table(unname(simulation2$simstates), file=outfn)

	outfn = slashslash(paste0(wd, "/", "simstates_living.txt"))
	write.table(unname(simulation2$simstates[index_in_fulltree_matching_living_tree_tipnode]), file=outfn)
	
	simulation2$tree = tr
	simulation2$tree_living = living_tree
	simulation2$simstates_all = simulation2$simstates
	names(simulation2$simstates_all) = c(names(simulation2$tip_states), tr$node.label)
	simulation2$simstates_living = simulation2$simstates_all[index_in_fulltree_matching_living_tree_tipnode]
	
	

	if (trynum <= numtries)
		{
		txt = paste0("simulate_tdsse2() found a tree after ", trynum, " tries. It has ", sum(fossils_TF==F), " living tips and ", sum(fossils_TF), " fossil tips. root_age=", round(root_age, digits=2), ".")
		cat("\n")
		cat(txt)
		#print(living_tree)
		} 
	cat("\n")
	
	# Further process simulation
	return(simulation2)
	} # END simulate_tdsse2_for_timeperiod <- function(wd, start_state=2, max_simulation_time=10, min_tips=2, simfns=default_simfns(), seedval=54321, max_rate=10.0)



get_root_age <- function(tr)
	{
	tip_ages_above_root = get_node_ages_of_tips(simulation2$tree)
	root_age = max(tip_ages_above_root)
	return(root_age)
	}
	
		







#######################################################
# Remove last tip from a simulation object
#######################################################
# Remove a final tip from a simulation objection, reordering everything accordingly
# Identifies the internal node to drop as the highest node above the root
# (assumes simulation object has been reordered)
# simulation2 = reorder_castor_sim_to_default_ape_node_order(simulation)

remove_last_tip_from_simulation <- function(simulation)
	{
	# Node times
	last_tips_TF = simulation$birth_times == simulation$final_time

	# Edit cladogenetic event counts
	last_node_state = simulation$node_states[length(simulation$node_states)]
	last2 = length(simulation$tip_states)-2
	last1 = length(simulation$tip_states)-1
	descendent_tip_states = simulation$tip_states[last2:last1]

	# Remove a pair of cladogenetic transitions from counts
	simulation$Ntransitions_C[last_node_state,descendent_tip_states[1]] = simulation$Ntransitions_C[last_node_state,descendent_tip_states[1]] - 1

	simulation$Ntransitions_C[last_node_state,descendent_tip_states[2]] = simulation$Ntransitions_C[last_node_state,descendent_tip_states[2]] - 1

	# Remove a birth event from counts
	simulation$Nbirths[last_node_state] = simulation$Nbirths[last_node_state] - 1

	# Drop stuff

	# Drop last node (in TIME!!!)
	tipnums = 1:length(simulation$tree$tip.label)
	nodenums = (length(simulation$tree$tip.label)+1):(length(simulation$tree$tip.label)+simulation$tree$Nnode)
	nodenums_1based = 1:simulation$tree$Nnode
	trtable = prt(t=simulation$tree, printflag=FALSE, get_tipnames=TRUE)
	internal_trtable_rows = trtable[nodenums,]
	highest_node_TF = internal_trtable_rows$node_ht == max(internal_trtable_rows$node_ht)
	highest_nodenum = nodenums[highest_node_TF]
	nodenums_1based_to_drop = nodenums_1based[highest_node_TF]
	simulation$node_states = simulation$node_states[-nodenums_1based_to_drop]
	
	# Drop last tip
	tipname_to_drop = simulation$tree$tip.label[trtable$daughter_nds[highest_nodenum][[1]][2]]
	simulation$tree = drop.tip(simulation$tree, tip=tipname_to_drop)

	# Drop last birth time and tip state
	simulation$birth_times = simulation$birth_times[last_tips_TF==FALSE]
	
	# Matching tipname to drop
	tipname_to_drop_TF = names(simulation$tip_states) == tipname_to_drop
	simulation$tip_states = simulation$tip_states[tipname_to_drop_TF == FALSE]

	# Drop last node - OLD
	# simulation$node_states = simulation$node_states[-length(simulation$node_states)]

	return(simulation)
	}

	




write_out_original_castor_simfiles <- function(simulation, wd, fn="rawsim")
	{
	
	# Write the raw tree
	original_simtree = simulation$tree
	trfn = slashslash(paste0(wd, "/", fn, "_orig_castor_tree.newick"))
	write.tree(original_simtree, file=trfn)
	
	original_simtree = simulation$tree
	original_simtree_wSp = original_simtree
	original_simtree_wSp$tip.label = paste0("sp", original_simtree_wSp$tip.label)
	trfn = slashslash(paste0(wd, "/", fn, "_orig_castor_tree_wSp.newick"))
	write.tree(original_simtree_wSp, file=trfn)
	
	# Save the original Rdata output
	outfn = slashslash(paste0(wd, "/", fn, "_orig_castor_sim.Rdata"))
	save(simulation, file=outfn)
	
	# Original castor simstates
	simstates_in_orig_castor_order = c(unname(simulation$tip_states), simulation$node_states)
	simstates_in_orig_castor_order = cbind(1:length(simstates_in_orig_castor_order), simstates_in_orig_castor_order)
	simstates_in_orig_castor_order = as.data.frame(simstates_in_orig_castor_order, stringsAsFactors=FALSE)
	names(simstates_in_orig_castor_order) = c("nodenum", "simstate")
	
	outfn = slashslash(paste0(wd, "/", fn, "_simstates_in_orig_castor_order.txt"))
	write.table(simstates_in_orig_castor_order, file=outfn, quote=FALSE, sep="\t", col.names=TRUE, row.names=FALSE)
	
	}



write_out_reordered_castor_simfiles <- function(simulation, wd, area_names, states_list, tip_age_tolerance=1e-6)
	{
	numareas = length(area_names)
	states_list_0based = states_list
	
	simulation2 = reorder_castor_sim_to_default_ape_node_order(simulation)

	tip_ages_above_root = get_node_ages_of_tips(simulation2$tree)
	root_age = max(tip_ages_above_root)

	#tip_age_tolerance = 1e-6
	fossils_TF = (root_age - tip_ages_above_root) > tip_age_tolerance

	# 1. output a successful simulation
	# 2. save to a living tree and complete tree
	tr = simulation2$tree
	tr$node.label = paste0("in", ((length(tr$tip.label)+1):(length(tr$tip.label)+tr$Nnode)))
	tr$tip.label = paste0("sp", tr$tip.label)
	tips_to_drop = tr$tip.label[fossils_TF]
	living_tree = drop.tip(phy=tr, tip=tips_to_drop)
	
	full_tree_tipnode_labels = c(tr$node.label, tr$tip.label)
	living_tree_tipnode_labels = c(living_tree$node.label, living_tree$tip.label)
	
	index_in_fulltree_matching_living_tree_node = match(living_tree$node.label, table=tr$node.label)
	length(index_in_fulltree_matching_living_tree_node)
	length(living_tree$node.label)
	length(tr$node.label)

	index_in_fulltree_matching_living_tree_tipnode = match(living_tree_tipnode_labels, table=full_tree_tipnode_labels)
	length(index_in_fulltree_matching_living_tree_tipnode)
	length(living_tree_tipnode_labels)
	length(full_tree_tipnode_labels)


	#trtable_all = prt(t=tr, printflag=FALSE, get_tipnames=TRUE)
	#trtable_living = prt(t=living_tree, printflag=FALSE, get_tipnames=TRUE)
	
	
	outfn = slashslash(paste0(wd, "/", "living_tree.newick"))
	write.tree(living_tree, file=outfn)
	living_tree_noNodeLabels = living_tree
	living_tree_noNodeLabels$node.label = NULL
	outfn = slashslash(paste0(wd, "/", "living_tree_noNodeLabels.newick"))
	write.tree(living_tree_noNodeLabels, file=outfn)
	
	outfn = slashslash(paste0(wd, "/", "full_tree.newick"))
	write.tree(tr, file=outfn)
	outfn = slashslash(paste0(wd, "/", "tree_wFossils.newick"))
	write.tree(tr, file=outfn)
	tree_wFossils_noNodeLabels = tr
	tree_wFossils_noNodeLabels$node.label = NULL
	outfn = slashslash(paste0(wd, "/", "tree_wFossils_noNodeLabels.newick"))
	write.tree(tree_wFossils_noNodeLabels, file=outfn)
	
	
	#	3. geog files for both
	
	# Write out the geography files
	all_tip_states = simulation2$tip_states
	
	tipnames = tr$tip.label
	tmpdf = NULL
	for (i in 1:length(all_tip_states))
		{
		tmprow = rep(0, times=numareas) # e.g. 00
		tmpstate = 1+ states_list_0based[all_tip_states[i]][[1]] # 0-based states list must add 1
		tmprow[tmpstate] = 1  # if tmpstate is NA, nothing converted from 0 to 1
		tmpdf = rbind(tmpdf, tmprow)
		}
	
	tmpdf = as.data.frame(tmpdf)
	names(tmpdf) = area_names
	row.names(tmpdf) = paste0("sp", names(all_tip_states))
	tipranges = define_tipranges_object(tmpdf=tmpdf)
	
	lgdata_fn = slashslash(paste0(wd, "/", "geog_wFossils.data"))
	save_tipranges_to_LagrangePHYLIP(tipranges, lgdata_fn=lgdata_fn, areanames=area_names)
	
	# Subset to living-only
	rows_to_drop_TF = row.names(tmpdf) %in% tips_to_drop
	rows_to_keep_TF = rows_to_drop_TF == FALSE
	tmpdf2 = tmpdf[rows_to_keep_TF,]
	tipranges2 = define_tipranges_object(tmpdf=tmpdf2)
	lgdata_fn = slashslash(paste0(wd, "/", "geog_living.data"))
	save_tipranges_to_LagrangePHYLIP(tipranges2, lgdata_fn=lgdata_fn, areanames=area_names)
	
	#	4. save the Rdata file
	outfn = slashslash(paste0(wd, "/", "reordered_castor_sim.Rdata"))
	save(simulation2, file=outfn)
	
	#	5. save the states at tips & nodes
	outfn = slashslash(paste0(wd, "/", "simstates_all.txt"))
	write.table(unname(simulation2$simstates), file=outfn)

	outfn = slashslash(paste0(wd, "/", "simstates_living.txt"))
	write.table(unname(simulation2$simstates[index_in_fulltree_matching_living_tree_tipnode]), file=outfn)
	

	}






